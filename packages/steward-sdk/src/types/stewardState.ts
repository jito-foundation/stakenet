/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getArrayDecoder,
  getArrayEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  getU16Decoder,
  getU16Encoder,
  getU32Decoder,
  getU32Encoder,
  getU64Decoder,
  getU64Encoder,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  getBitMaskDecoder,
  getBitMaskEncoder,
  getDelegationDecoder,
  getDelegationEncoder,
  getStewardStateEnumDecoder,
  getStewardStateEnumEncoder,
  type BitMask,
  type BitMaskArgs,
  type Delegation,
  type DelegationArgs,
  type StewardStateEnum,
  type StewardStateEnumArgs,
} from '.';

/**
 * Tracks state of the stake pool.
 * Follow state transitions here:
 * https://github.com/jito-foundation/stakenet/blob/master/programs/steward/state-machine-diagram.png
 */

export type StewardState = {
  /** Current state of the Steward */
  stateTag: StewardStateEnum;
  /**
   * Internal lamport balance of each validator, used to track stake deposits that need to be unstaked,
   * so not always equal to the stake account balance.
   */
  validatorLamportBalances: Array<bigint>;
  /** Overall score of validator, used to determine delegates and order for delegation. */
  scores: Array<number>;
  /** Indices of validators, sorted by score descending */
  sortedScoreIndices: Array<number>;
  /** Yield component of the score. Used as secondary priority, to determine order for unstaking. */
  yieldScores: Array<number>;
  /** Indices of validators, sorted by yield score descending */
  sortedYieldScoreIndices: Array<number>;
  /** Target share of pool represented as a proportion, indexed by spl_stake_pool::ValidatorList index */
  delegations: Array<Delegation>;
  /** Each bit represents a validator, true if validator should be unstaked */
  instantUnstake: BitMask;
  /** Tracks progress of states that require one instruction per validator */
  progress: BitMask;
  /**
   * Marks a validator for immediate removal after `remove_validator_from_pool` has been called on the stake pool
   * This happens when a validator is able to be removed within the same epoch as it was marked
   */
  validatorsForImmediateRemoval: BitMask;
  /**
   * Marks a validator for removal after `remove_validator_from_pool` has been called on the stake pool
   * This is cleaned up in the next epoch
   */
  validatorsToRemove: BitMask;
  /** Slot of the first ComputeScores instruction in the current cycle */
  startComputingScoresSlot: bigint;
  /** Internal current epoch, for tracking when epoch has changed */
  currentEpoch: bigint;
  /** Next cycle start */
  nextCycleEpoch: bigint;
  /**
   * Number of validators in the stake pool, used to determine the number of validators to be scored.
   * Updated at the start of each cycle and when validators are removed.
   */
  numPoolValidators: bigint;
  /** Total lamports that have been due to scoring this cycle */
  scoringUnstakeTotal: bigint;
  /** Total lamports that have been due to instant unstaking this cycle */
  instantUnstakeTotal: bigint;
  /** Total lamports that have been due to stake deposits this cycle */
  stakeDepositUnstakeTotal: bigint;
  /** Flags to track state transitions and operations */
  statusFlags: number;
  /** Number of validators added to the pool in the current cycle */
  validatorsAdded: number;
  /** Future state and #[repr(C)] alignment */
  padding0: ReadonlyUint8Array;
};

export type StewardStateArgs = {
  /** Current state of the Steward */
  stateTag: StewardStateEnumArgs;
  /**
   * Internal lamport balance of each validator, used to track stake deposits that need to be unstaked,
   * so not always equal to the stake account balance.
   */
  validatorLamportBalances: Array<number | bigint>;
  /** Overall score of validator, used to determine delegates and order for delegation. */
  scores: Array<number>;
  /** Indices of validators, sorted by score descending */
  sortedScoreIndices: Array<number>;
  /** Yield component of the score. Used as secondary priority, to determine order for unstaking. */
  yieldScores: Array<number>;
  /** Indices of validators, sorted by yield score descending */
  sortedYieldScoreIndices: Array<number>;
  /** Target share of pool represented as a proportion, indexed by spl_stake_pool::ValidatorList index */
  delegations: Array<DelegationArgs>;
  /** Each bit represents a validator, true if validator should be unstaked */
  instantUnstake: BitMaskArgs;
  /** Tracks progress of states that require one instruction per validator */
  progress: BitMaskArgs;
  /**
   * Marks a validator for immediate removal after `remove_validator_from_pool` has been called on the stake pool
   * This happens when a validator is able to be removed within the same epoch as it was marked
   */
  validatorsForImmediateRemoval: BitMaskArgs;
  /**
   * Marks a validator for removal after `remove_validator_from_pool` has been called on the stake pool
   * This is cleaned up in the next epoch
   */
  validatorsToRemove: BitMaskArgs;
  /** Slot of the first ComputeScores instruction in the current cycle */
  startComputingScoresSlot: number | bigint;
  /** Internal current epoch, for tracking when epoch has changed */
  currentEpoch: number | bigint;
  /** Next cycle start */
  nextCycleEpoch: number | bigint;
  /**
   * Number of validators in the stake pool, used to determine the number of validators to be scored.
   * Updated at the start of each cycle and when validators are removed.
   */
  numPoolValidators: number | bigint;
  /** Total lamports that have been due to scoring this cycle */
  scoringUnstakeTotal: number | bigint;
  /** Total lamports that have been due to instant unstaking this cycle */
  instantUnstakeTotal: number | bigint;
  /** Total lamports that have been due to stake deposits this cycle */
  stakeDepositUnstakeTotal: number | bigint;
  /** Flags to track state transitions and operations */
  statusFlags: number;
  /** Number of validators added to the pool in the current cycle */
  validatorsAdded: number;
  /** Future state and #[repr(C)] alignment */
  padding0: ReadonlyUint8Array;
};

export function getStewardStateEncoder(): FixedSizeEncoder<StewardStateArgs> {
  return getStructEncoder([
    ['stateTag', getStewardStateEnumEncoder()],
    [
      'validatorLamportBalances',
      getArrayEncoder(getU64Encoder(), { size: 5000 }),
    ],
    ['scores', getArrayEncoder(getU32Encoder(), { size: 5000 })],
    ['sortedScoreIndices', getArrayEncoder(getU16Encoder(), { size: 5000 })],
    ['yieldScores', getArrayEncoder(getU32Encoder(), { size: 5000 })],
    [
      'sortedYieldScoreIndices',
      getArrayEncoder(getU16Encoder(), { size: 5000 }),
    ],
    ['delegations', getArrayEncoder(getDelegationEncoder(), { size: 5000 })],
    ['instantUnstake', getBitMaskEncoder()],
    ['progress', getBitMaskEncoder()],
    ['validatorsForImmediateRemoval', getBitMaskEncoder()],
    ['validatorsToRemove', getBitMaskEncoder()],
    ['startComputingScoresSlot', getU64Encoder()],
    ['currentEpoch', getU64Encoder()],
    ['nextCycleEpoch', getU64Encoder()],
    ['numPoolValidators', getU64Encoder()],
    ['scoringUnstakeTotal', getU64Encoder()],
    ['instantUnstakeTotal', getU64Encoder()],
    ['stakeDepositUnstakeTotal', getU64Encoder()],
    ['statusFlags', getU32Encoder()],
    ['validatorsAdded', getU16Encoder()],
    ['padding0', fixEncoderSize(getBytesEncoder(), 40002)],
  ]);
}

export function getStewardStateDecoder(): FixedSizeDecoder<StewardState> {
  return getStructDecoder([
    ['stateTag', getStewardStateEnumDecoder()],
    [
      'validatorLamportBalances',
      getArrayDecoder(getU64Decoder(), { size: 5000 }),
    ],
    ['scores', getArrayDecoder(getU32Decoder(), { size: 5000 })],
    ['sortedScoreIndices', getArrayDecoder(getU16Decoder(), { size: 5000 })],
    ['yieldScores', getArrayDecoder(getU32Decoder(), { size: 5000 })],
    [
      'sortedYieldScoreIndices',
      getArrayDecoder(getU16Decoder(), { size: 5000 }),
    ],
    ['delegations', getArrayDecoder(getDelegationDecoder(), { size: 5000 })],
    ['instantUnstake', getBitMaskDecoder()],
    ['progress', getBitMaskDecoder()],
    ['validatorsForImmediateRemoval', getBitMaskDecoder()],
    ['validatorsToRemove', getBitMaskDecoder()],
    ['startComputingScoresSlot', getU64Decoder()],
    ['currentEpoch', getU64Decoder()],
    ['nextCycleEpoch', getU64Decoder()],
    ['numPoolValidators', getU64Decoder()],
    ['scoringUnstakeTotal', getU64Decoder()],
    ['instantUnstakeTotal', getU64Decoder()],
    ['stakeDepositUnstakeTotal', getU64Decoder()],
    ['statusFlags', getU32Decoder()],
    ['validatorsAdded', getU16Decoder()],
    ['padding0', fixDecoderSize(getBytesDecoder(), 40002)],
  ]);
}

export function getStewardStateCodec(): FixedSizeCodec<
  StewardStateArgs,
  StewardState
> {
  return combineCodec(getStewardStateEncoder(), getStewardStateDecoder());
}
