/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getArrayDecoder,
  getArrayEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getF64Decoder,
  getF64Encoder,
  getStructDecoder,
  getStructEncoder,
  getU16Decoder,
  getU16Encoder,
  getU32Decoder,
  getU32Encoder,
  getU64Decoder,
  getU64Encoder,
  getU8Decoder,
  getU8Encoder,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  type ReadonlyUint8Array,
} from '@solana/kit';

export type Parameters = {
  /** Number of epochs to consider for MEV commission */
  mevCommissionRange: number;
  /** Number of epochs to consider for epoch credits */
  epochCreditsRange: number;
  /** Number of epochs to consider for commission */
  commissionRange: number;
  /** Highest MEV commission rate allowed in bps */
  mevCommissionBpsThreshold: number;
  /** Proportion of delinquent slots to total slots to trigger delinquency measurement in scoring */
  scoringDelinquencyThresholdRatio: number;
  /** Proportion of delinquent slots to total slots to trigger instant unstake */
  instantUnstakeDelinquencyThresholdRatio: number;
  /** Highest commission rate allowed in commission_range epochs, in percent */
  commissionThreshold: number;
  /** Highest commission rate allowed in tracked history */
  historicalCommissionThreshold: number;
  /** The number of epochs the priority fee distribution check should lookback */
  priorityFeeLookbackEpochs: number;
  /**
   * The offset of epochs for the priority fee distribution. E.g. look at epochs from
   * (current_epoch - offset - priority_fee_lookback_epochs) to (current_epoch - offset)
   */
  priorityFeeLookbackOffset: number;
  /**
   * The maximum validator commission before the validator scores 0.
   * E.g. 5_000 bps (50%) would mean: if the validator keeps > 50% of priority fees,
   * then score = 0
   */
  priorityFeeMaxCommissionBps: number;
  /** An error of margin for priority fee commission calculations */
  priorityFeeErrorMarginBps: number;
  /** Number of validators to delegate to */
  numDelegationValidators: number;
  /** Maximum amount of the pool to be unstaked in a cycle for scoring (in basis points) */
  scoringUnstakeCapBps: number;
  instantUnstakeCapBps: number;
  /** Maximum amount of the pool to be unstaked in a cycle from stake deposits (in basis points) */
  stakeDepositUnstakeCapBps: number;
  /** Number of slots that scoring must be completed in */
  computeScoreSlotRange: bigint;
  /** Progress in epoch before instant unstake is allowed */
  instantUnstakeEpochProgress: number;
  /** Validator history copy_vote_account and Cluster History must be updated past this epoch progress before calculating instant unstake */
  instantUnstakeInputsEpochProgress: number;
  /** Number of epochs a given validator set will be delegated to before recomputing scores */
  numEpochsBetweenScoring: bigint;
  /** Minimum stake required to be added to pool ValidatorList and eligible for delegation */
  minimumStakeLamports: bigint;
  /** Minimum epochs voting required to be in the pool ValidatorList and eligible for delegation */
  minimumVotingEpochs: bigint;
  /** The epoch when priority fee scoring starts. Scores default to 1 for all prior epochs */
  priorityFeeScoringStartEpoch: number;
  padding0: ReadonlyUint8Array;
  padding1: Array<bigint>;
};

export type ParametersArgs = {
  /** Number of epochs to consider for MEV commission */
  mevCommissionRange: number;
  /** Number of epochs to consider for epoch credits */
  epochCreditsRange: number;
  /** Number of epochs to consider for commission */
  commissionRange: number;
  /** Highest MEV commission rate allowed in bps */
  mevCommissionBpsThreshold: number;
  /** Proportion of delinquent slots to total slots to trigger delinquency measurement in scoring */
  scoringDelinquencyThresholdRatio: number;
  /** Proportion of delinquent slots to total slots to trigger instant unstake */
  instantUnstakeDelinquencyThresholdRatio: number;
  /** Highest commission rate allowed in commission_range epochs, in percent */
  commissionThreshold: number;
  /** Highest commission rate allowed in tracked history */
  historicalCommissionThreshold: number;
  /** The number of epochs the priority fee distribution check should lookback */
  priorityFeeLookbackEpochs: number;
  /**
   * The offset of epochs for the priority fee distribution. E.g. look at epochs from
   * (current_epoch - offset - priority_fee_lookback_epochs) to (current_epoch - offset)
   */
  priorityFeeLookbackOffset: number;
  /**
   * The maximum validator commission before the validator scores 0.
   * E.g. 5_000 bps (50%) would mean: if the validator keeps > 50% of priority fees,
   * then score = 0
   */
  priorityFeeMaxCommissionBps: number;
  /** An error of margin for priority fee commission calculations */
  priorityFeeErrorMarginBps: number;
  /** Number of validators to delegate to */
  numDelegationValidators: number;
  /** Maximum amount of the pool to be unstaked in a cycle for scoring (in basis points) */
  scoringUnstakeCapBps: number;
  instantUnstakeCapBps: number;
  /** Maximum amount of the pool to be unstaked in a cycle from stake deposits (in basis points) */
  stakeDepositUnstakeCapBps: number;
  /** Number of slots that scoring must be completed in */
  computeScoreSlotRange: number | bigint;
  /** Progress in epoch before instant unstake is allowed */
  instantUnstakeEpochProgress: number;
  /** Validator history copy_vote_account and Cluster History must be updated past this epoch progress before calculating instant unstake */
  instantUnstakeInputsEpochProgress: number;
  /** Number of epochs a given validator set will be delegated to before recomputing scores */
  numEpochsBetweenScoring: number | bigint;
  /** Minimum stake required to be added to pool ValidatorList and eligible for delegation */
  minimumStakeLamports: number | bigint;
  /** Minimum epochs voting required to be in the pool ValidatorList and eligible for delegation */
  minimumVotingEpochs: number | bigint;
  /** The epoch when priority fee scoring starts. Scores default to 1 for all prior epochs */
  priorityFeeScoringStartEpoch: number;
  padding0: ReadonlyUint8Array;
  padding1: Array<number | bigint>;
};

export function getParametersEncoder(): FixedSizeEncoder<ParametersArgs> {
  return getStructEncoder([
    ['mevCommissionRange', getU16Encoder()],
    ['epochCreditsRange', getU16Encoder()],
    ['commissionRange', getU16Encoder()],
    ['mevCommissionBpsThreshold', getU16Encoder()],
    ['scoringDelinquencyThresholdRatio', getF64Encoder()],
    ['instantUnstakeDelinquencyThresholdRatio', getF64Encoder()],
    ['commissionThreshold', getU8Encoder()],
    ['historicalCommissionThreshold', getU8Encoder()],
    ['priorityFeeLookbackEpochs', getU8Encoder()],
    ['priorityFeeLookbackOffset', getU8Encoder()],
    ['priorityFeeMaxCommissionBps', getU16Encoder()],
    ['priorityFeeErrorMarginBps', getU16Encoder()],
    ['numDelegationValidators', getU32Encoder()],
    ['scoringUnstakeCapBps', getU32Encoder()],
    ['instantUnstakeCapBps', getU32Encoder()],
    ['stakeDepositUnstakeCapBps', getU32Encoder()],
    ['computeScoreSlotRange', getU64Encoder()],
    ['instantUnstakeEpochProgress', getF64Encoder()],
    ['instantUnstakeInputsEpochProgress', getF64Encoder()],
    ['numEpochsBetweenScoring', getU64Encoder()],
    ['minimumStakeLamports', getU64Encoder()],
    ['minimumVotingEpochs', getU64Encoder()],
    ['priorityFeeScoringStartEpoch', getU16Encoder()],
    ['padding0', fixEncoderSize(getBytesEncoder(), 6)],
    ['padding1', getArrayEncoder(getU64Encoder(), { size: 31 })],
  ]);
}

export function getParametersDecoder(): FixedSizeDecoder<Parameters> {
  return getStructDecoder([
    ['mevCommissionRange', getU16Decoder()],
    ['epochCreditsRange', getU16Decoder()],
    ['commissionRange', getU16Decoder()],
    ['mevCommissionBpsThreshold', getU16Decoder()],
    ['scoringDelinquencyThresholdRatio', getF64Decoder()],
    ['instantUnstakeDelinquencyThresholdRatio', getF64Decoder()],
    ['commissionThreshold', getU8Decoder()],
    ['historicalCommissionThreshold', getU8Decoder()],
    ['priorityFeeLookbackEpochs', getU8Decoder()],
    ['priorityFeeLookbackOffset', getU8Decoder()],
    ['priorityFeeMaxCommissionBps', getU16Decoder()],
    ['priorityFeeErrorMarginBps', getU16Decoder()],
    ['numDelegationValidators', getU32Decoder()],
    ['scoringUnstakeCapBps', getU32Decoder()],
    ['instantUnstakeCapBps', getU32Decoder()],
    ['stakeDepositUnstakeCapBps', getU32Decoder()],
    ['computeScoreSlotRange', getU64Decoder()],
    ['instantUnstakeEpochProgress', getF64Decoder()],
    ['instantUnstakeInputsEpochProgress', getF64Decoder()],
    ['numEpochsBetweenScoring', getU64Decoder()],
    ['minimumStakeLamports', getU64Decoder()],
    ['minimumVotingEpochs', getU64Decoder()],
    ['priorityFeeScoringStartEpoch', getU16Decoder()],
    ['padding0', fixDecoderSize(getBytesDecoder(), 6)],
    ['padding1', getArrayDecoder(getU64Decoder(), { size: 31 })],
  ]);
}

export function getParametersCodec(): FixedSizeCodec<
  ParametersArgs,
  Parameters
> {
  return combineCodec(getParametersEncoder(), getParametersDecoder());
}
